" vi: filetype=vim
let s:vim_path = expand('~/.vim')
let s:vimrc = expand('~/.vimrc')
if has("nvim")
  let s:vim_path = expand('~/.config/nvim')
  let s:vimrc = expand('~/.config/nvim/init.vim')
endif

"" ==================== Pre Plug ====================
" Only load vim-test if these commands are used
let vimTestCommands = ['TestNearest', 'TestFile', 'TestSuite', 'TestLast', 'TestVisit']

"" ==================== Vim Plug ====================
call plug#begin(s:vim_path.'/plugged')

" Core Bundles
Plug 'lervag/file-line'                     " Handle filenames with line numbers i.e. :20
Plug 'mhinz/vim-signify'                    " + & - in column for changed lines
Plug 'tpope/vim-fugitive'                   " Git integration ':Gstatus' etc.
Plug 'tpope/vim-characterize'               " Adds 'ga' command to show character code
Plug 'tpope/vim-commentary'                 " Adds 'gc' & 'gcc' commands for commenting lines
Plug 'tpope/vim-eunuch'                     " Adds unix commands like ':Move' etc.
Plug 'tpope/vim-surround'                   " Adds 'cs' command to change surround e.g. cs'<p> - would change 'this' => <p>this</p>
Plug 'tpope/vim-dispatch', {
  \ 'on': 'Dispatch' }                      " Async vim compiler plugins (used to run mocha test below)
Plug 'jaawerth/nrun.vim'                    " Put locally installed npm module .bin at front of path
Plug 'tpope/vim-sleuth'                     " Detect indentation
Plug 'christoomey/vim-tmux-navigator'       " Seemless vim <-> tmux navigation
Plug 'itchyny/lightline.vim'                " Status line plugin
Plug 'sheerun/vim-polyglot'                 " Syntax highlighting
Plug 'ryanoasis/vim-devicons'               " Filetype icons
Plug 'wincent/scalpel'                      " Easier find & replace
Plug 'janko-m/vim-test', {
  \ 'on': vimTestCommands }                 " easy testing
Plug 'tweekmonster/startuptime.vim', {
  \ 'on': 'StartupTime' }                   " easier vim startup time profiling
Plug 'iamcco/markdown-preview.nvim', {
  \ 'do': ':call mkdp#util#install()',
  \ 'for': 'markdown',
  \ 'on': 'MarkdownPreview' }               " Markdown previewing commands
Plug 'rhysd/git-messenger.vim', {
  \ 'on': 'GitMessenger' }                  " Git blame for line with commit message

{{- if .neovim_nightly }}
Plug '~/git/nvcode-color-schemes.vim'       " treesitter colorscheme
Plug 'nvim-treesitter/nvim-treesitter', {
  \ 'do': ':TSUpdate' }                     " better syntax highlighting
Plug 'nvim-treesitter/playground'           " playground for illustrating the AST treesitter builds
Plug 'nvim-lua/popup.nvim'                  " dependency of telescope
Plug 'nvim-lua/plenary.nvim'                " dependency of telescope
Plug 'nvim-telescope/telescope.nvim'        " whizzy command-p launcher
Plug 'kyazdani42/nvim-web-devicons'         " devicons for lua plugins
Plug 'neovim/nvim-lspconfig'                " native neovim LSP support
Plug 'nvim-lua/lsp-status.nvim'             " LSP status display
{{- else }}
Plug 'neoclide/coc.nvim', {
  \ 'branch': 'release' }                   " LSPish integration
Plug 'liuchengxu/vim-clap', {
  \ 'do': { -> clap#installer#force_download() } } " whizzy command-p launcher
Plug 'vn-ki/coc-clap'                       " Integrate coc.nvim with vim-clap
{{- end }}

call plug#end()

"" ==================== General ====================
set lazyredraw                  "Improve scrolling performance with cursorline
set ttyfast                     "More characters will be sent to the screen for redrawing
set ttimeout
set ttimeoutlen=50              "Time waited for key press(es) to complete. It makes for a faster key response
set showcmd                     "Display incomplete commands
set wildmenu                    "A better menu in command mode
set wildmode=longest:full,full
set scrolloff=4                 "Number of lines from vertical edge to start scrolling
set number                      "Adds line numbers
set cursorline                  "Highlight line the cursor is on
set colorcolumn=80              "Add column line at 80 characters
set splitbelow                  "Better split defaults
set splitright
set autoindent                  "Sets up auto indent (copies indentation from line above)
set incsearch                   "Highlight dynamically as pattern is typed
set hlsearch                    "Highlight search
set ignorecase                  "Case insensitive search
set smartcase                   "Case sensitive when search contains upper-case characters
set wildignorecase              "Ignore case when opening files
set laststatus=2                "Always display the status line
set showtabline=2               "Always show tabline
set noswapfile                  "Disable swap files
set autoread                    "Automatically read changes in the file
set hidden                      "Hide buffers instead of closing them even if they contain unwritten changes
set backspace=indent,eol,start  "Make backspace behave properly in insert mode
set noshowmode                  "Hide the default mode text (e.g. -- INSERT -- below the statusline)
set tabstop=4                   "Changes tabs to 4 spaces
set shiftwidth=2                "Determines indentation in normal mode (using '>>' or '<<')
set softtabstop=2               "Let backspace delete indent
set expandtab                   "Expands tabs to spaces, better for formatting
set spelllang=en                "Set vim's spell check language
set termguicolors               "Better terminal color support in neovim

let mapleader = ","
let maplocalleader = "\\"

"" ==================== Config ====================
" disable sleuth for markdown files due to slowdown caused in combination with
" vim-polyglot
autocmd FileType markdown let b:sleuth_automatic = 0

" Automatically resize vim splits on resize
autocmd VimResized * execute "normal! \<c-w>="

" Save and load vim views - remembers scroll position & folds
autocmd BufWinLeave *.* mkview
autocmd BufWinEnter *.* silent! loadview

{{- if eq "crostini" .ostype }}
" Configure vim's other clipboard registers to use xsel (system clipboard)
let g:clipboard = {
\   'name': 'crostiniClipboard',
\   'copy': {
\      '+': 'xsel --clipboard',
\      '*': 'xsel --clipboard',
\    },
\   'paste': {
\      '+': 'xsel --clipboard',
\      '*': 'xsel --clipboard',
\   },
\   'cache_enabled': 1,
\ }
{{- end }}

"" ==================== Colors ====================
{{- if .neovim_nightly }}
let g:nvcode_termcolors=256

lua <<EOF
require "nvim-treesitter.configs".setup {
  ensure_installed = "all",
  highlight = {
    enable = true
  },
  playground = {
    enable = true,
    disable = {},
    updatetime = 25, -- Debounced time for highlighting nodes in the playground from source code
    persist_queries = false -- Whether the query persists across vim sessions
  }
}
EOF
{{- end }}

let g:nord_italic = 1
let g:nord_italic_comments = 1
let g:nord_underline = 1
let g:nord_uniform_diff_background = 1
let g:nord_cursor_line_number_background = 1

syntax enable
colorscheme nord

highlight Search    guibg=#81A1C1 guifg=#2E3440 ctermbg=blue ctermfg=black
highlight IncSearch guibg=#81A1C1 guifg=#2E3440 ctermbg=green ctermfg=black

" Treesitter overrides
highlight TSInclude   gui=italic cterm=italic
highlight TSOperator  gui=italic cterm=italic
highlight TSKeyword   gui=italic cterm=italic

"" ==================== Folding ====================
set foldmethod=syntax   "syntax highlighting items specify folds
set foldcolumn=2        "defines 1 col at window left, to indicate folding
set foldlevelstart=99   "start file with all folds opened

"" ==================== netrw ====================
let g:netrw_liststyle = 3

{{- if .neovim_nightly }}
"" ==================== telescope ====================
lua <<EOF
local actions = require('telescope.actions')
require('telescope').setup{
  defaults = {
    prompt_prefix = "❯",
    use_less = false,
    mappings = {
      i = {
        ["<c-s>"] = actions.goto_file_selection_split,
        ["<C-k>"] = actions.move_selection_previous,
        ["<C-j>"] = actions.move_selection_next,
      }
    }
  }
}
EOF

nnoremap <leader>l <cmd>Telescope buffers<cr>
nnoremap <leader>t <cmd>Telescope git_files<cr>
nnoremap <leader>f <cmd>Telescope live_grep<cr>
nnoremap <c-t> <cmd>Telescope git_files<cr>
nnoremap <c-f> <cmd>Telescope live_grep<cr>
nnoremap <leader>fw <cmd>Telescope grep_string<CR>

" Colors
highlight TelescopeBorder       guifg=#4C566A
highlight TelescopePromptBorder guifg=#5E81AC
highlight TelescopeMatching     guifg=#EBCB8B

{{- else }}
"" ==================== vim-clap ====================
let g:clap_open_action = {
\  'ctrl-t': 'tab split',
\  'ctrl-s': 'split',
\  'ctrl-v': 'vsplit'
\ }
let g:clap_layout = {
\ 'width': '90%',
\ 'height': '33%',
\ 'row': '33%',
\ 'col': '5%'
\ }
" Below doesn't work with icons despite being a very close copy of internal
" git_files provider - some custom handle I can't access allows icons support.
" Should re-enable when I can access it
let g:clap_provider_git_files_plus = {
\ 'source': 'git ls-files && git ls-files --others --exclude-standard',
\ 'sink': function('clap#provider#files#sink_impl'),
\ 'sink*': function('clap#provider#files#sink_star_impl'),
\ 'on_move': function('clap#provider#files#on_move_impl'),
\ 'syntax': 'clap_files',
\ 'enable_rooter': v:true,
\ 'support_open_action': v:true
\ }

nnoremap <leader>l :Clap buffers<CR>
nnoremap <leader>t :Clap git_files<CR>
nnoremap <leader>f :Clap grep2<CR>
nnoremap <c-t> :Clap git_files<CR>
nnoremap <c-f> :Clap grep2<CR>
nnoremap <leader>fw :Clap grep2 ++query=<cword><CR>
{{- end }}

"" ==================== Signify ====================
let g:signify_sign_add = "•"
let g:signify_sign_change = "•"
let g:signify_sign_delete = "•"
let g:signify_sign_changedelete = "•"
let g:signify_sign_show_count = 0
let g:signify_sign_show_text = 1
let g:signify_update_on_focusgained = 1

nmap gh <plug>(signify-next-hunk)
nmap gH <plug>(signify-prev-hunk)

"" ==================== Vim-test ====================
let g:test#runner_commands = ['Jest']
let g:test#strategy = "neovim"
let test#neovim#term_position = "vert botright"

" Below needed for tests inside spec folder
let g:test#javascript#jest#file_pattern = '\v((__tests__|spec)/.*|(spec|test))\.(js|jsx|coffee|ts|tsx)$'
let g:test#javascript#jest#executable = "yarn jest --watch"

nmap <silent> t<C-n> :TestNearest<CR>
nmap <silent> t<C-f> :TestFile<CR>
nmap <silent> t<C-w> :Jest --watch<CR>

"" ==================== Lightline ====================
{{- if not .neovim_nightly }}
let g:coc_status_warning_sign = "◆ "
let g:coc_status_error_sign = "⨯ "
{{- end }}

function! FileTypeIcon()
  return winwidth(0) > 70 ? (strlen(&filetype) ? WebDevIconsGetFileTypeSymbol() : '') : ''
endfunction

function! Git_branch() abort
  if fugitive#head() !=# ''
    return  fugitive#head() . "  "
  else
    return "\uf468"
  endif
endfunction

let g:lightline = {
\ 'colorscheme': 'nord',
\ 'active': {
\   'left': [['mode', 'paste'], ['filename', 'modified'], ['gitbranch']],
\   'right': [['percentinfo', 'lineinfo'], ['filetypeicon', 'filetype', 'readonly']]
\ },
\ 'component': {
\   'percentinfo': '≡ %3p%%',
\   'vim_logo': "\ue7c5 ",
\   'git_branch': '%{Git_branch()}',
\ },
\ 'component_function': {
\   'gitbranch': 'fugitive#head',
\   'filetypeicon': 'FileTypeIcon',
\ },
\ 'component_type': {
\   'readonly': 'error',
\ },
\ 'tabline': {
\   'left': [['vim_logo'], ['tabs']],
\   'right': [['git_branch']]
\ }
\ }

{{- if .neovim_nightly }}
function! LspStatus() abort
  if luaeval('#vim.lsp.buf_get_clients() > 0')
    return luaeval("require('lsp-status').status()")
  endif

  return ''
endfunction

let g:lightline.active.right = [['percentinfo', 'lineinfo'], ['filetypeicon', 'filetype', 'readonly'], ['lspstatus']]
let g:lightline.component_function.lspstatus = 'LspStatus'
{{- else }}
let g:lightline.active.right = [['percentinfo', 'lineinfo'], ['filetypeicon', 'filetype', 'readonly'], ['cocstatus']]
let g:lightline.component_function.cocstatus = 'coc#status'
let g:lightline.component_type.cocstatuswarn = 'warning'
let g:lightline.component_type.cocstatuserror = 'error'
{{- end }}

if ($TERM_EMU == 'kitty')
  let g:lightline.separator = { 'left': "", 'right': " " }
  let g:lightline.subseparator = { 'left': '\\', 'right': '\\' }
  let g:lightline.tabline_separator = { 'left': " ", 'right': "" }
  let g:lightline.tabline_subseparator = { 'left': "/", 'right': "/" }
endif

{{- if not .neovim_nightly }}
autocmd User CocStatusChange,CocDiagnosticChange call lightline#update()
{{- end }}

"" ==================== Scalpel ====================
let g:ScalpelCommand = 'S'
nmap <leader>e <Plug>(Scalpel)

{{- if .neovim_nightly }}
"" ==================== nvim-lspconfig ====================
lua <<EOF
local nvim_lsp = require('lspconfig')
local util = require('lspconfig/util')
local lsp_status = require('lsp-status')

lsp_status.register_progress()
lsp_status.config({
  current_function = false,
  status_symbol = "",
  indicator_errors = "⨯",
  indicator_warnings = "◆",
  indicator_info = "ⓘ ",
  indicator_hint = "…",
  indicator_ok = " "
})

local on_attach = function(client, bufnr)

  lsp_status.on_attach(client, bufnr)

  local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
  local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

  buf_set_option('omnifunc', 'v:lua.vim.lsp.omnifunc')
  vim.api.nvim_command('autocmd CursorHold <buffer> lua vim.lsp.diagnostic.show_line_diagnostics()')

  vim.api.nvim_command('highlight LspDiagnosticsDefaultError guifg=#BF616A')
  vim.api.nvim_command('highlight LspDiagnosticsDefaultWarning guifg=#EBCB8B')
  vim.api.nvim_command('highlight LspDiagnosticsDefaultInformation guifg=none')
  vim.api.nvim_command('highlight LspDiagnosticsDefaultHint guifg=none')

  vim.api.nvim_command('highlight LspDiagnosticsUnderlineError guifg=#BF616A gui=underline')
  vim.api.nvim_command('highlight LspDiagnosticsUnderlineWarning guifg=#EBCB8B gui=underline')
  vim.api.nvim_command('highlight LspDiagnosticsUnderlineInformation guifg=none gui=underline')
  vim.api.nvim_command('highlight LspDiagnosticsUnderlineHint guifg=none gui=underline')

  -- Mappings.
  local opts = { noremap=true, silent=true }
  buf_set_keymap('n', 'gD',         '<Cmd>lua vim.lsp.buf.declaration()<CR>', opts)
  buf_set_keymap('n', 'gd',         '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'gi',         '<cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', 'gr',         '<cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', 'K',          '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)

  -- other mappings, not sure about these
  buf_set_keymap('n', '<space>wa',  '<cmd>lua vim.lsp.buf.add_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wr',  '<cmd>lua vim.lsp.buf.remove_workspace_folder()<CR>', opts)
  buf_set_keymap('n', '<space>wl',  '<cmd>lua print(vim.inspect(vim.lsp.buf.list_workspace_folders()))<CR>', opts)
  buf_set_keymap('n', '<space>D',   '<cmd>lua vim.lsp.buf.type_definition()<CR>', opts)
  buf_set_keymap('n', '<space>rn',  '<cmd>lua vim.lsp.buf.rename()<CR>', opts)
  buf_set_keymap('n', '<space>e',   '<cmd>lua vim.lsp.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', '[d',         '<cmd>lua vim.lsp.diagnostic.goto_prev()<CR>', opts)
  buf_set_keymap('n', ']d',         '<cmd>lua vim.lsp.diagnostic.goto_next()<CR>', opts)
  buf_set_keymap('n', '<space>q',   '<cmd>lua vim.lsp.diagnostic.set_loclist()<CR>', opts)

  -- Set some keybinds conditional on server capabilities
  if client.resolved_capabilities.document_formatting then
    buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.formatting()<CR>", opts)
  elseif client.resolved_capabilities.document_range_formatting then
    buf_set_keymap("n", "<space>f", "<cmd>lua vim.lsp.buf.range_formatting()<CR>", opts)
  end
end

-- Stolen from lspconfig/tsserver, would have been nice to be able to import
local get_ts_root_dir = function(fname)
  return util.root_pattern("tsconfig.json")(fname) or
  util.root_pattern("package.json", "jsconfig.json", ".git")(fname);
end

-- Make tsserver work with yarn v2
local get_tsserver_exec = function()
  local ts_root_dir = get_ts_root_dir(vim.fn.getcwd())
  local coc_settings = ts_root_dir .. "/.vim/coc-settings.json"

  -- not yarn v2 project
  if util.path.exists(coc_settings) == false then
    return "node_modules/.bin/tsserver"
  else
    local file = io.open(coc_settings):read("*a")
    local coc_json = vim.fn.json_decode(file)
    local ts_key = "tsserver.tsdk"
    return coc_json[ts_key] .. "/tsserver.js"
  end
end

local tsserver_exec = get_tsserver_exec()

nvim_lsp.tsserver.setup {
  handlers = {
   ["textDocument/publishDiagnostics"] = vim.lsp.with(
     vim.lsp.diagnostic.on_publish_diagnostics, {
       -- Enable signs
       signs = true,
       -- Disable virtual_text
       virtual_text = false,
     }
   ),
  },
  cmd = {
    "typescript-language-server",
    "--stdio",
    "--tsserver-path",
    tsserver_exec
  },
  on_attach = on_attach,
  capabilities = lsp_status.capabilities
}

local eslint = {
  lintCommand = "node_modules/.bin/eslint -f unix --stdin --stdin-filename ${INPUT}",
  lintIgnoreExitCode = true,
  lintStdin = true
}

local get_line_content_position = function(line)
  local line_len = string.len(line)
  local line_ltrim = string.match(line, '^%s*(.*)$')

  return {
    ["start"] = line_len - string.len(line_ltrim),
    ["end"] = line_len
  }
end

-- Need to install efm via `go get`
-- https://github.com/mattn/efm-langserver#installation
nvim_lsp.efm.setup {
  handlers = {
    ["textDocument/publishDiagnostics"] = function(err, method, params, client_id, bufnr, config)
      vim.tbl_map(
        function(value)
          local line_num = value.range["end"].line + 1
          local line = vim.api.nvim_eval("getline(".. line_num ..")")

          local line_content_pos = get_line_content_position(line)

          value.range["start"].character = line_content_pos["start"]
          value.range["end"].character = line_content_pos["end"]
        end,
        params.diagnostics
      )

      local on_diagnostics = vim.lsp.with(
        vim.lsp.diagnostic.on_publish_diagnostics, {
          -- Enable signs
          signs = true,
          -- Disable virtual_text
          virtual_text = false,
        }
      )
      return on_diagnostics(err, method, params, client_id, bufnr, config)
    end
  },
  init_options = { documentFormatting = true },
  filetypes = { "javascript", "javascriptreact", "typescript", "typescriptreact" },
  root_dir = function(fname)
    return util.root_pattern("tsconfig.json")(fname) or
    util.root_pattern(".eslintrc.js", ".git")(fname);
  end,
  settings = {
    rootMarkers = { ".eslintrc.js", ".git/" },
    languages = {
      javascript = { eslint },
      javascriptreact = { eslint },
      typescript = { eslint },
      typescriptreact = { eslint }
    }
  },
  on_attach = on_attach,
  capabilities = lsp_status.capabilities
}
EOF
{{- else }}
"" ==================== Coc-nvim ====================
let g:coc_global_extensions = [
\  'coc-eslint',
\  'coc-prettier',
\  'coc-json',
\  'coc-tsserver',
\  'coc-markdownlint',
\  'coc-deno'
\ ]

inoremap <expr> <C-j> pumvisible() ? "\<C-n>" : "\<C-j>"
inoremap <expr> <C-k> pumvisible() ? "\<C-p>" : "\<C-k>"

nmap <silent> gd <Plug>(coc-definition)
nmap <silent> gy <Plug>(coc-type-definition)
nmap <silent> gi <Plug>(coc-implementation)
nmap <silent> gr <Plug>(coc-references)

" Remap keys for applying codeAction to the current line.
nmap <leader>ac  <Plug>(coc-codeaction)
" Apply AutoFix to problem on the current line.
nmap <leader>qf  <Plug>(coc-fix-current)

" Use K to show documentation in preview window
nnoremap <silent> K :call <SID>show_documentation()<CR>

function! s:show_documentation()
  if (index(['vim','help'], &filetype) >= 0)
    execute 'h '.expand('<cword>')
  else
    call CocAction('doHover')
  endif
endfunction
{{- end }}

function! OpenZippedFile(f)
  " get number of new (empty) buffer
  let l:b = bufnr('%')
  " construct full path
  let l:f = substitute(a:f, '.zip/', '.zip::', '')
  let l:f = substitute(l:f, '/zip:', 'zipfile:', '')

  " swap back to original buffer
  b #
  " delete new one
  exe 'bd! ' . l:b
  " open buffer with correct path
  sil exe 'e ' . l:f
  " read in zip data
  call zip#Read(l:f, 1)
endfunction

autocmd BufReadCmd /zip:*.yarn/cache/*.zip/* call OpenZippedFile(expand('<afile>'))

"" ==================== Fugitive ====================
let g:fugitive_dynamic_colors = 0
autocmd BufReadPost fugitive://* set bufhidden=delete       "Stops fugitive files being left in buffer by removing all but currently visible

"" ==================== Key (re)Mappings ====================
" Makes up/down on line wrapped lines work better (more intuitive)
nnoremap j gj
nnoremap k gk

"keep text selected after indentation
vnoremap < <gv
vnoremap > >gv

" Shows and hides invisible characters
nnoremap <leader>- :resize -5<CR>
nnoremap <leader>= :resize +5<CR>
nnoremap <leader>. :vertical resize -20<CR>
nnoremap <leader>, :vertical resize +20<CR>
nnoremap <leader>x :cclose<CR>
nnoremap <leader>h :set hlsearch!<CR>
nnoremap <leader>n :set number!<CR>
nnoremap <leader>w :%s/\s\+$//e<CR>:echom "Cleared whitespace"<CR>
nnoremap <leader>evv :vsplit $MYVIMRC<CR>
nnoremap <leader>ev :split $MYVIMRC<CR>
nnoremap <leader>sv :source $MYVIMRC<CR>:echom 'Reloaded '. $MYVIMRC<CR>
nnoremap <leader>ff :Ex<CR>
nnoremap <leader>fp :echo @%<CR>
nnoremap <leader>ga :Git add %:p<CR><CR>
nnoremap <leader>gs :Gstatus<CR>
nnoremap <leader>gc :Gcommit -v -q<CR>
nnoremap <leader>gt :Gcommit -v -q %:p<CR>
nnoremap <leader>gd :Gvdiff<CR>
nnoremap <leader>ge :Gedit<CR>
nnoremap <leader>gr :Gread<CR>
nnoremap <leader>gw :Gwrite<CR><CR>
nnoremap <leader>gl :silent! Glog<CR>:bot copen<CR>
nnoremap <leader>gp :Ggrep -n<Space>
nnoremap <leader>gm :GitMessenger<CR>
nnoremap <leader>gb :Git branch<Space>
nnoremap <leader>go :Git checkout<Space>
nnoremap <leader>gps :Dispatch! git push<CR>
nnoremap <leader>gpl :Dispatch! git pull<CR>

" Esc (C-[) to escape terminal insert mode
tnoremap <Esc> <C-\><C-n>
tnoremap <A-[> <Esc>

if filereadable(expand('~/.vimrc.local'))
  source ~/.vimrc.local
endif
